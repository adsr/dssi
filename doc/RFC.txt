

Request for comments: Disposable Soft Synth Interface (DSSI)
============================================================

Background and Requirements
---------------------------

One of the biggest barriers to the acceptance of Linux audio software
as a direct alternative to mainstream sequencer applications for other
platforms is the lack of a comparable way to operate software synth
plugins.  There is an immediate need for an API that permits synth
plugins to be written to a simple standard and then used in a range of
host applications.

This is an awkward situation, because it is hoped that the forthcoming
GMPI initiative will comprehensively address the needs of soft synths
in a flexible cross-platform way.  But the requirement for Linux
applications to be able to support simple hosted synths is here now,
and GMPI is not.  Thus, we need to provide the simplest possible
interim solution in a way that will prove compelling enough to support
now, yet not so compelling as to supplant GMPI or any other
comprehensive future proposal.  Hence this RFC: the Disposable Soft
Synth Interface, or DSSI (pronounced "dizzy").

Because of the conservative nature of this proposal, the main
requirements are:

1/ To support the basic facilities that users and developers familiar
with mainstream software on other platforms will expect to find in a
Linux alternative: the ability to take a synth plugin with a cute GUI
and to direct MIDI (from e.g. a sequencer track) to it, automate its
controls, and route the output appropriately.  Note that there is an
emphasis on MIDI throughout this discussion.

2/ To address certain specific limitations of other methods of running
MIDI soft synths on Linux.  These limitations are discussed below.

3/ To take advantage of existing work as much as possible.


Existing Techniques
-------------------

There are of course ways to run MIDI soft synths on Linux already, as
well as some other initiatives that address parts of the same problem
as this one.

* ALSA sequencer input + JACK output (the "standalone soft synth")

Most existing Linux soft synths operate as standalone applications
that wait for MIDI events on an ALSA sequencer port and generate audio
to JACK outputs.  This is an attractively flexible solution, because
such applications are by definition routeable in the same way as any
other MIDI devices and JACK clients.  For some synths, particularly
larger ones with significant amounts of internal configuration state,
this may actually be a very effective way to work.

Unfortunately routing only the MIDI and audio streams is not usually
enough, especially for smaller dedicated synths.  The applications
wanting to route to a synth need more information about it than is
actually available in this way.  For example, it is impossible to
identify that an ALSA application is in fact a synth, or discover its
available programs or controller settings; there is no reliable way to
associate the synth's inputs with its outputs in order to route both
ends at once; and it is extremely hard to manage multiple instances.
Also the use of the ALSA sequencer layer to deliver incoming events
means that they can't be timed to exact sample frames.  All of these
are limitations which the present proposal needs to address.

* LADSPA

The existing Linux plugin standard can't easily be used for MIDI soft
synths, because there is no way to pass MIDI or MIDI-like data to a
plugin.  (A plugin could open its own ALSA sequencer input, but that
is complex and carries the same timing limitation as discussed above.)
There is also no toolkit-agnostic standard way to provide a user
interface with a LADSPA plugin.

* MIDI-over-JACK

An extension has been proposed to the JACK framework to permit MIDI
events to be sent via JACK.  If used to drive a conventional soft
synth, this would fully address the timing problem that exists in the
ALSA sequencer method, but not any of its other limitations.

* LASH (formerly LADCCA)

The LASH Audio Session Handler, formerly known as Linux Audio
Developers' Connection and Configuration API, is a service that
performs session management for projects using audio applications: it
starts the applications corresponding to a given project, connects
their MIDI and audio connections, coordinates saving of project data,
and so on.  (The applications have to be written to use the LASH
service.)  This could be used to address some of the problems in the
ALSA sequencer method, specifically those related to managing
connections for instances that have already been positioned in a
connection graph.  LASH could be used with MIDI-over-JACK, thus also
solving the timing problem.  Unfortunately none of this addresses the
problem of discovering synths and the available configurations of
those synths in the first place.

* libsynti

The MusE sequencer has an API for hosting soft synths, known as
libsynti.  It is probably the closest alternative to the present
proposal, it addresses many of the same problems, it is working now,
and it is an attractively small API.  Unfortunately it is unlikely to
be popular as a standard for Linux audio plugins, simply because it is
in C++ and requires Qt for plugin GUIs.

* VSTi

Mentioned for completeness.  The licensing for the VST SDK is not at
all compatible with the GPL or any other free-software license, which
is one reason why LADSPA exists.  Also VSTi is complex to implement
correctly, hard to automate, and in the context of a Linux GUI toolkit
it would not readily solve the GUI problem.  The attractiveness of the
fact that there are many plugins already available is diminished by
the fact that their source is usually not, so they can't be rebuilt
for Linux except by their authors.


The DSSI Proposal In Brief
--------------------------

* Define a DSSI plugin as a wrapper for a LADSPA plugin, which is to
  be used for all control and audio data.  (Thus taking advantage of
  the existing widespread awareness of how LADSPA works, as well as
  functioning mechanisms for handling controls, instantiation etc.)

* Provide additional mechanisms for querying and changing programs,
  mapping MIDI controllers to LADSPA control ports, and running a
  synth with a set of frame-timestamped MIDI events using the existing
  ALSA sequencer event type struct.  (Thus ensuring timing correctness
  and enabling the host to query the various additional bits of
  non-MIDI non-audio information it needs.)

The above two parts of the proposal are documented thoroughly in the
dssi.h header file.

* Make the plugin UI a separate standalone program, that communicates
  with the host (_not_ directly with the plugin) via Open Sound Control
  messages.  (Thus ducking out of the GUI toolkit compatibility
  question altogether, ensuring that the plugin is always correctly
  automatable by the host, and in principle permitting plugins to be
  controlled by other OSC clients as well.)

This part of the proposal is documented below.


DSSI Synth UIs
--------------

A synth user interface is an executable program, not a part of the
plugin or a separate shared object.  A host may elect to start or stop
the UI for a plugin at any time, starting and terminating the
executable at will.

1. In General

The UI and host communicate with one another using OSC, the OpenSound
Control protocol.  See

  http://www.cnmat.berkeley.edu/OpenSoundControl/

OSC is a simple message-based protocol intended for communications
among sound devices.  DSSI does not mandate any particular
implementation of OSC, but it does require that it be based on a UDP
transport (OSC itself is transport-independent).  The example code
uses an implementation by Steve Harris called liblo ("Lite OSC") which
can be obtained from

  http://www.plugin.org.uk/liblo/

Note that liblo is distributed under a different licence from DSSI and
so might not be a legal option for certain DSSI implementations.

DSSI uses OSC in both directions between the host and UI.  When a
user changes a port value in the UI, it sends an OSC request to the
host, which informs the plugin of the change; when an automated port
change occurs in the host, it sends an update to the UI.  (The host
does not send updates to the UI for port changes that the UI itself
initiated; likewise the UI must not send port changes back to the
host that the host itself initiated.)

Communications between the host and UI are deliberately as limited as
possible.  There is, for example, no way for a UI to query the
available port names, values, ranges etc for a plugin.  It's expected
that the UI will either share some code with the plugin so that it
knows these things already, or will itself also load the plugin DLL
and query it directly.

2. Discovery and Startup

The mechanism by which a host locates and invokes the UI for a plugin
is host-dependent.

Our recommendation is this: for a plugin labelled PLUGIN found in a
dll named PLUGINS.so in directory DIRECTORY, the host may look in the
directory DIRECTORY/PLUGINS/ for executable files beginning with the
string PLUGIN.  (If there are several, the expectation is that the
suffix will somehow determine the host's preference -- for example,
PLUGIN_qt, PLUGIN_gl -- a convention for this ought to be determined.)

The host then starts the chosen executable with a command line
consisting of:
  * the executable name in argv[0] as normal
  * the OSC URL for the host, identifying the host and the base path
    for the correct plugin instance (see Paths and Methods below)
  * the name of the .so in which the plugin was found (here PLUGINS.so)
  * the label of the plugin (here PLUGIN).

The UI then requests an update, passing its own OSC URL and base path
to the host; the host responds by sending the current values of all
the ports, and startup is complete.

3. Paths and Methods

An OSC method call consists of a path -- identifying the method being
called -- and a sequence of typed arguments. 

The DSSI host and UI are each expected to think of an arbitrary path
to associate with each plugin instance, known as the "base path".
This will presumably have some internal and/or diagnostic meaning:
e.g. a host might use "/dssi/PLUGINS/PLUGIN.1" for the path to the
first instance of plugin labelled PLUGIN in PLUGINS.so.  Individual
method calls are always made to a subpath of the base path, as
detailed below.

Base paths are exchanged on startup: the host gives its path to the
UI on the command line, the UI returns its own as the argument to an
update call.

These are the methods the host may support:

  <base path>/control  (e.g. "/dssi/PLUGINS/PLUGIN.1/control")
  Set a control port value on the plugin at <base path>.  Takes an int
  argument for port number and a float for value.  (required method)

  <base path>/program
  Make a program change on the plugin.  Takes two int arguments, for
  bank and program number.  (required method)

  <base path>/update
  Request an update on the UI.  Takes one string argument, the UI's
  own OSC URL with base path.  The host should respond by sending the
  current state of the plugin to the UI in a series of control and
  program OSC calls.  (required method, and the UI is required to
  use it)
  
  <base path>/configure
  Make a configure() call to the plugin.  Takes two string arguments
  for key and value.  See the documentation for configure() in dssi.h.
  (required method)

  <base path>/midi
  Send an arbitrary MIDI event to the plugin.  Takes a four-byte MIDI
  string.  This is expected to be used for note data generated from a
  test panel on the UI, for example.  It should not be used for
  program or controller changes, sysex data, etc.  A host should
  feel free to drop any values it doesn't wish to pass on.  No
  guarantees are provided about timing accuracy, etc, of the MIDI
  communication.  (optional method)

And these are the methods the UI may support:

  <base path>/control
  Update the UI from an automated control change.  Takes an int
  argument for port number and float for value.  (required method)

  <base path>/program
  Update the UI from an automated program change.  Takes an int
  argument for bank number and int for value.  (required method if
  the plugin supports program changes)


"Project Plan"
--------------

1/ Think of an API.

2/ Test it to make sure it's not totally stupid.

Iterate for a bit between 1 and 2 until it's clear that total
stupidity is no longer in the air.

3/ Take it to LAD and see how well it goes down.  If it looks as
though a workable consensus based on this proposal can be reached,
then try to reach it and get some implementations done.  Otherwise
reframe or abandon.

